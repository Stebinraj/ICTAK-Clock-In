// router.get('/tracker/:_id', (req, res) => {
//     userModel.find({ "_id": req.params._id }, (err, data) => {
//         let ObjectId = req.params._id;
//         userModel.aggregate([
//             { $match: { _id: ObjectId } },
//             {
//                 $lookup: {
//                     from: 'trackers',
//                     localField: '_id',
//                     foreignField: 'empId',
//                     as: 'works'
//                 }
//             },
//             {
//                 $unwind: '$works'
//             }
//         ])
//             .then(data => {
//                 res.send(data);
//             })
//     })
// });


// router.get('/total/:_id', (req, res) => {
//     const startOfDay = new Date(new Date().setHours(0, 0, 0, 0));
//     const endOfDay = new Date(new Date().setHours(23, 59, 59, 999));

//     const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay()));
//     const endOfWeek = new Date(new Date().setDate(startOfWeek.getDate() + 6));

//     const startOfMonth = new Date(new Date().getFullYear(), new Date().getMonth(), 1);
//     const endOfMonth = new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0);

//     const startOfYear = new Date(new Date().getFullYear(), 0, 1);
//     const endOfYear = new Date(new Date().getFullYear(), 11, 31);

//     userModel.findById({ '_id': req.params._id })
//         .then(user => {
//             if (!user) {
//                 res.status(404).send('User not found.');
//             } else {
//                 return trackerModel.find({ 'empId': req.params._id });
//             }
//         })
//         .then(trackerData => {
//             const entriesToday = trackerData.filter(entry => entry.startTime >= startOfDay && entry.endTime <= endOfDay);
//             const totalHoursToday = calculateTotalHours(entriesToday);

//             const entriesThisWeek = trackerData.filter(entry => entry.startTime >= startOfWeek && entry.endTime <= endOfWeek);
//             const totalHoursThisWeek = calculateTotalHours(entriesThisWeek);

//             const entriesThisMonth = trackerData.filter(entry => entry.startTime >= startOfMonth && entry.endTime <= endOfMonth);
//             const totalHoursThisMonth = calculateTotalHours(entriesThisMonth);

//             const entriesThisYear = trackerData.filter(entry => entry.startTime >= startOfYear && entry.endTime <= endOfYear);
//             const totalHoursThisYear = calculateTotalHours(entriesThisYear);

//             res.json({
//                 totalHoursToday: formatHours(totalHoursToday),
//                 totalHoursThisWeek: formatHours(totalHoursThisWeek),
//                 totalHoursThisMonth: formatHours(totalHoursThisMonth),
//                 totalHoursThisYear: formatHours(totalHoursThisYear)
//             });
//         })
//         .catch(err => {
//             console.log(err);
//             res.status(500).send('Error occurred while fetching data.');
//         });

//     function calculateTotalHours(entries) {
//         let totalHours = 0;
//         entries.forEach(entry => {
//             const hours = (entry.endTime.getTime() - entry.startTime.getTime()) / (1000 * 60 * 60);
//             totalHours += hours;
//         });
//         return totalHours;
//     }

//     function formatHours(hours) {
//         const numHours = Math.floor(hours);
//         const numMinutes = Math.floor((hours - numHours) * 60);
//         const numSeconds = Math.floor(((hours - numHours) * 60 - numMinutes) * 60);
//         return `${numHours.toString().padStart(2, '0')}:${numMinutes.toString().padStart(2, '0')}:${numSeconds.toString().padStart(2, '0')}`;
//     }
// });

// router.get('/total/:_id/:date', (req, res) => {
//     const inputDate = new Date(req.params.date);
//     const startOfDay = new Date(inputDate.setHours(0, 0, 0, 0));
//     const endOfDay = new Date(inputDate.setHours(23, 59, 59, 999));

//     userModel.findById({ '_id': req.params._id })
//         .then(user => {
//             if (!user) {
//                 res.status(404).send('User not found.');
//             } else {
//                 return trackerModel.find({ 'empId': req.params._id });
//             }
//         })
//         .then(trackerData => {
//             const entriesToday = trackerData.filter(entry => entry.startTime >= startOfDay && entry.endTime <= endOfDay);
//             const totalHoursToday = calculateTotalHours(entriesToday);

//             res.json({
//                 totalHoursToday: formatHours(totalHoursToday)
//             });
//         })
//         .catch(err => {
//             console.log(err);
//             res.status(500).send('Error occurred while fetching data.');
//         });

//     function calculateTotalHours(entries) {
//         let totalHours = 0;
//         entries.forEach(entry => {
//             const hours = (entry.endTime.getTime() - entry.startTime.getTime()) / (1000 * 60 * 60);
//             totalHours += hours;
//         });
//         return totalHours;
//     }

//     function formatHours(hours) {
//         const numHours = Math.floor(hours);
//         const numMinutes = Math.floor((hours - numHours) * 60);
//         const numSeconds = Math.floor(((hours - numHours) * 60 - numMinutes) * 60);
//         return `${numHours.toString().padStart(2, '0')}:${numMinutes.toString().padStart(2, '0')}:${numSeconds.toString().padStart(2, '0')}`;
//     }
// });

// router.get('/total/:_id/week/:year/:week', (req, res) => {
//     const inputYear = parseInt(req.params.year);
//     const inputWeek = parseInt(req.params.week);
//     const startOfWeek = new Date(new Date(inputYear, 0, 1).getTime() + ((inputWeek - 1) * 7 * 24 * 60 * 60 * 1000));
//     const endOfWeek = new Date(startOfWeek.getTime() + 6 * 24 * 60 * 60 * 1000);

//     userModel.findById({ '_id': req.params._id })
//         .then(user => {
//             if (!user) {
//                 res.status(404).send('User not found.');
//             } else {
//                 return trackerModel.find({ 'empId': req.params._id });
//             }
//         })
//         .then(trackerData => {
//             const entriesThisWeek = trackerData.filter(entry => entry.startTime >= startOfWeek && entry.endTime <= endOfWeek);
//             const totalHoursThisWeek = calculateTotalHours(entriesThisWeek);

//             res.json({
//                 totalHoursThisWeek: formatHours(totalHoursThisWeek)
//             });
//         })
//         .catch(err => {
//             console.log(err);
//             res.status(500).send('Error occurred while fetching data.');
//         });


//     function calculateTotalHours(entries) {
//         let totalHours = 0;
//         entries.forEach(entry => {
//             const hours = (entry.endTime.getTime() - entry.startTime.getTime()) / (1000 * 60 * 60);
//             totalHours += hours;
//         });
//         return totalHours;
//     }

//     function formatHours(hours) {
//         const numHours = Math.floor(hours);
//         const numMinutes = Math.floor((hours - numHours) * 60);
//         const numSeconds = Math.floor(((hours - numHours) * 60 - numMinutes) * 60);
//         return `${numHours.toString().padStart(2, '0')}:${numMinutes.toString().padStart(2, '0')}:${numSeconds.toString().padStart(2, '0')}`;
//     }
// });


// router.get('/total/:_id/month/:year/:month', (req, res) => {
//     const inputYear = parseInt(req.params.year);
//     const inputMonth = parseInt(req.params.month) - 1;
//     const startOfMonth = new Date(inputYear, inputMonth, 1);
//     const endOfMonth = new Date(inputYear, inputMonth + 1, 0);

//     userModel.findById({ '_id': req.params._id })
//         .then(user => {
//             if (!user) {
//                 res.status(404).send('User not found.');
//             } else {
//                 return trackerModel.find({ 'empId': req.params._id });
//             }
//         })
//         .then(trackerData => {
//             const entriesThisMonth = trackerData.filter(entry => entry.startTime >= startOfMonth && entry.endTime <= endOfMonth);
//             const totalHoursThisMonth = calculateTotalHours(entriesThisMonth);

//             res.json({
//                 totalHoursThisMonth: formatHours(totalHoursThisMonth)
//             });
//         })
//         .catch(err => {
//             console.log(err);
//             res.status(500).send('Error occurred while fetching data.');
//         });


//     function calculateTotalHours(entries) {
//         let totalHours = 0;
//         entries.forEach(entry => {
//             const hours = (entry.endTime.getTime() - entry.startTime.getTime()) / (1000 * 60 * 60);
//             totalHours += hours;
//         });
//         return totalHours;
//     }

//     function formatHours(hours) {
//         const numHours = Math.floor(hours);
//         const numMinutes = Math.floor((hours - numHours) * 60);
//         const numSeconds = Math.floor(((hours - numHours) * 60 - numMinutes) * 60);
//         return `${numHours.toString().padStart(2, '0')}:${numMinutes.toString().padStart(2, '0')}:${numSeconds.toString().padStart(2, '0')}`;
//     }
// });


// router.get("/tracker/:_id/:interval", (req, res) => {
//     userModel.find({ _id: req.params._id }, (err, data) => {
//       let ObjectId = req.params._id;
//       userModel.aggregate([
//         { $match: { _id: ObjectId } },
//         {
//           $lookup: {
//             from: "trackers",
//             localField: "_id",
//             foreignField: "empId",
//             as: "works",
//           },
//         },
//         { $unwind: "$works" },
//         {
//           $group: {
//             _id:
//               req.params.interval === "daily"
//                 ? {
//                     $dateToString: { format: "%Y-%m-%d", date: "$works.timestamp" },
//                   }
//                 : req.params.interval === "weekly"
//                 ? {
//                     $dateToString: { format: "%Y-%U", date: "$works.timestamp" },
//                   }
//                 : req.params.interval === "monthly"
//                 ? {
//                     $dateToString: { format: "%Y-%m", date: "$works.timestamp" },
//                   }
//                 : {
//                     $dateToString: { format: "%Y", date: "$works.timestamp" },
//                   },
//             value: { $sum: "$works.value" },
//           },
//         },
//       ])
//         .then((data) => {
//           res.send(data);
//         })
//         .catch((err) => {
//           console.log(err);
//           res.send(err);
//         });
//     });
//   });



// router.get('/tracker/:_id/:range', (req, res) => {
//     let ObjectId = req.params._id;
//     let range = req.params.range;
//     let match;
//     switch (range) {
//         case 'daily':
//             match = {
//                 "works.startTime": {
//                     "$gte": new Date(new Date().setHours(0, 0, 0, 0)),
//                     "$lt": new Date(new Date().setHours(23, 59, 59, 999))
//                 }
//             };
//             break;
//         case 'weekly':
//             match = {
//                 "works.startTime": {
//                     "$gte": new Date(new Date().setDate(new Date().getDate() - new Date().getDay())),
//                     "$lt": new Date(new Date(new Date().setDate(new Date().getDate() - new Date().getDay())).setDate(new Date().getDate() + 6))
//                 }
//             };
//             break;
//         case 'monthly':
//             match = {
//                 "works.startTime": {
//                     "$gte": new Date(new Date().setDate(1)),
//                     "$lt": new Date(new Date(new Date().setMonth(new Date().getMonth() + 1)).setDate(0))
//                 }
//             };
//             break;
//         case 'yearly':
//             match = {
//                 "works.startTime": {
//                     "$gte": new Date(new Date().setMonth(0).setDate(1)),
//                     "$lt": new Date(new Date(new Date().setMonth(11).setDate(31)))
//                 }
//             };
//             break;
//         default:
//             res.status(400).send({ error: 'Invalid range provided' });
//             return;
//     }

//     userModel.aggregate([
//         { $match: { _id: ObjectId } },
//         {
//             $lookup: {
//                 from: 'trackers',
//                 localField: '_id',
//                 foreignField: 'empId',
//                 as: 'works'
//             }
//         },
//         {
//             $unwind: '$works'
//         },
//         {
//             $match: match
//         }
//     ])
//         .then(data => {
//             res.send(data);
//         })
// });



router.get('/daily/:_id', async (req, res) => {
    const user = await userModel.findOne({ _id: req.params._id });
    const empId = req.params._id;
    const today = moment().startOf('day');
    const tomorrow = moment(today).add(1, 'days');
    const data = await trackerModel.find({ empId, startTime: { $gte: today, $lt: tomorrow } });
    res.json(data);
});

router.get('/weekly/:_id', async (req, res) => {
    const user = await userModel.findOne({ _id: req.params._id });
    const empId = req.params._id;
    const startOfWeek = moment().startOf('week');
    const endOfWeek = moment().endOf('week');
    const data = await trackerModel.aggregate([
        { $match: { empId, startTime: { $gte: startOfWeek, $lt: endOfWeek } } },
        {
            $group: {
                _id: { $dayOfWeek: '$startTime' },
                totalTime: { $sum: { $subtract: ['$endTime', '$startTime'] } },
            },
        },
    ]);
    res.json(data);
});

router.get('/monthly/:_id', async (req, res) => {
    const user = await userModel.findOne({ _id: req.params._id });
    const empId = req.params._id;
    const startOfMonth = moment().startOf('month');
    const endOfMonth = moment().endOf('month');
    const data = await trackerModel.aggregate([
        { $match: { empId, startTime: { $gte: startOfMonth, $lt: endOfMonth } } },
        {
            $group: {
                _id: { $dayOfMonth: '$startTime' },
                totalTime: { $sum: { $subtract: ['$endTime', '$startTime'] } },
            },
        },
    ]);
    res.json(data);
});

router.get('/yearly/:_id', async (req, res) => {
    const user = await userModel.findOne({ _id: req.params._id });
    const empId = req.params._id;
    const startOfYear = moment().startOf('year');
    const endOfYear = moment().endOf('year');
    const data = await trackerModel.aggregate([
        { $match: { empId, startTime: { $gte: startOfYear, $lt: endOfYear } } },
        {
            $group: {
                _id: { $month: '$startTime' },
                totalTime: { $sum: { $subtract: ['$endTime', '$startTime'] } },
            },
        },
    ]);
    res.json(data);
});

















15-feb-2023







To convert this code for a React frontend and backend with datepicker for daily, weekly, monthly and yearly options, you will need to make several changes to the code. Here's an example implementation:

Backend:

router.get('/:_id/:option', async (req, res) => {
const { _id, option } = req.params;
const { startDate, endDate } = req.query;
const user = await userModel.findOne({ _id });
const empId = user._id;
let startTime, endTime;

switch(option) {
case "daily":
startTime = moment(startDate).startOf("day");
endTime = moment(endDate).endOf("day");
break;
case "weekly":
startTime = moment(startDate).startOf("week");
endTime = moment(endDate).endOf("week");
break;
case "monthly":
startTime = moment(startDate).startOf("month");
endTime = moment(endDate).endOf("month");
break;
case "yearly":
startTime = moment(startDate).startOf("year");
endTime = moment(endDate).endOf("year");
break;
default:
return res.status(400).json({ error: "Invalid option selected" });
}

const data = await trackerModel.find({ empId, startTime: { $gte: startTime, $lte: endTime } });
res.json(data);
});

The above code receives the employee ID and the option parameter as inputs, which can be "daily", "weekly", "monthly" or "yearly". It also receives two query parameters, startDate and endDate, which correspond to the range of dates to retrieve data for. The code then calculates the start and end times based on the selected option and query parameters, and retrieves the corresponding data from the database.

Frontend:

import React, { useState } from "react";
import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";

function App() {
const [selectedOption, setSelectedOption] = useState("daily");
const [startDate, setStartDate] = useState(new Date());
const [endDate, setEndDate] = useState(new Date());

const fetchData = async () => {
const res = await fetch(/api/tracker/${userId}/${selectedOption}?startDate=${startDate}&endDate=${endDate});
const data = await res.json();
console.log(data);
};

return (
<div>
<select value={selectedOption} onChange={(e) => setSelectedOption(e.target.value)}>
<option value="daily">Daily</option>
<option value="weekly">Weekly</option>
<option value="monthly">Monthly</option>
<option value="yearly">Yearly</option>
</select>
<DatePicker selected={startDate} onChange={date => setStartDate(date)} />
<DatePicker selected={endDate} onChange={date => setEndDate(date)} />
<button onClick={fetchData}>Fetch Data</button>
</div>
);
}

The frontend code uses the React DatePicker library to allow the user to select a start and end date. It also includes a select dropdown to select the desired option. When the "Fetch Data" button is clicked, it makes a request to the backend API with the selected option and date range as query parameters. The retrieved data is then logged to the console for testing purposes.

Note that in both the frontend and backend code, you will need to replace userId with the actual ID of the logged-in user. You will also need to import the necessary libraries and models, and set up the appropriate routes and controllers in your backend.







19-feb-2023

{/* <div className="dropdown employee-tracker-dropdown">

                <select value={project} onChange={handleProject}>
                    <option value="">Project</option>
                    {projectData.map((item, index) => {
                        return (
                            <option key={index} value={item.value}>{item.label}</option>
                        )
                    })}
                </select>

                <select value={task} onChange={handleTask}>
                    <option value="">Task</option>
                    {taskData.map((item, index) => {
                        return (
                            <option key={index} value={item.value}>{item.label}</option>
                        )
                    })}
                </select>

                <input type="text" placeholder='Job Description' onChange={handleJobDesc} />

                <select value={modeOfWork} onChange={handleModeOfWork}>
                    <option value="">Mode of Work</option>
                    <option value="Work from Office">Work from Office</option>
                    <option value="Work from Home">Work from Home</option>
                </select>

                <div>
                    <span>{("0" + Math.floor((time / 3600000) % 60)).slice(-2)}:</span>
                    <span>{("0" + Math.floor((time / 60000) % 60)).slice(-2)}:</span>
                    <span>{("0" + Math.floor((time / 1000) % 60)).slice(-2)}</span>
                </div>

                <div>
                    {running ?
                        (
                            <>
                                <button onClick={stop}>Stop</button>
                                <button onClick={pause}>Pause</button>
                            </>
                        )
                        :
                        (
                            <button onClick={start}>Start</button>
                        )}
                </div>
            </div>

            <table className="table">
                <thead>
                    <tr>
                        <th scope="col" >Project</th>
                        <th scope="col">Task</th>
                        <th scope="col">Job Description</th>
                        <th scope="col">Mode of Work</th>
                        <th scope="col">Start Time</th>
                        <th scope="col">End Time</th>
                        <th scope="col">Total Time</th>
                    </tr>
                </thead>
                <tbody>
                    {apiData.map((value, index) => {
                        return (
                            <tr key={index}>
                                <td>{value.project}</td>
                                <td>{value.task}</td>
                                <td>{value.jobDescription}</td>
                                <td>{value.modeOfWork}</td>
                                <td >{moment(value.startTime).format('HH:mm:ss')}</td>
                                <td>{moment(value.endTime).format('HH:mm:ss')}</td>
                                <td>{moment.utc(moment(value.endTime).diff(moment(value.startTime))).format("HH:mm:ss")}</td>
                            </tr>
                        )
                    })}
                </tbody>
            </table> */}

            {/* <div class="dropdown employee-tracker-dropdown">
                <select class="form-select" value={project} onChange={handleProject}>
                    <option value="">Project</option>
                    {projectData.map((item, index) => {
                        return (
                            <option key={index} value={item.value}>{item.label}</option>
                        )
                    })}
                </select>

                <select class="form-select" value={task} onChange={handleTask}>
                    <option value="">Task</option>
                    {taskData.map((item, index) => {
                        return (
                            <option key={index} value={item.value}>{item.label}</option>
                        )
                    })}
                </select>

                <select class="form-select" value={modeOfWork} onChange={handleModeOfWork}>
                    <option value="">Mode of Work</option>
                    <option value="Work from Office">Work from Office</option>
                    <option value="Work from Home">Work from Home</option>
                </select>

                <div class="input-group" style={{ width: '50%' }}>
                    <input type="text" class="form-control" placeholder='Job Description' onChange={handleJobDesc} />
                </div>

                <div class="timer">
                    <span>{("0" + Math.floor((time / 3600000) % 60)).slice(-2)}:</span>
                    <span>{("0" + Math.floor((time / 60000) % 60)).slice(-2)}:</span>
                    <span>{("0" + Math.floor((time / 1000) % 60)).slice(-2)}</span>
                </div>

                <div>
                    {running ?
                        (
                            <>
                                <button class="btn btn-outline-secondary" onClick={stop}>Stop</button>
                                <button class="btn btn-outline-secondary" onClick={pause}>Pause</button>
                            </>
                        )
                        :
                        (
                            <button class="btn btn-outline-secondary" onClick={start}>Start</button>
                        )}
                </div>
            </div> */}

            {/* <div class="container">
                <div class="row justify-content-center">
                    <div class="col-lg-12 col-md-10">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="dropdown employee-tracker-dropdown">
                                    <select class="form-select" value={project} onChange={handleProject}>
                                        <option value="">Project</option>
                                        {projectData.map((item, index) => {
                                            return (
                                                <option key={index} value={item.value}>{item.label}</option>
                                            )
                                        })}
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="dropdown employee-tracker-dropdown">
                                    <select class="form-select" value={task} onChange={handleTask}>
                                        <option value="">Task</option>
                                        {taskData.map((item, index) => {
                                            return (
                                                <option key={index} value={item.value}>{item.label}</option>
                                            )
                                        })}
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="dropdown employee-tracker-dropdown">
                                    <select class="form-select" value={modeOfWork} onChange={handleModeOfWork}>
                                        <option value="">Mode of Work</option>
                                        <option value="Work from Office">Work from Office</option>
                                        <option value="Work from Home">Work from Home</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="input-group">
                                    <input type="text" class="form-control" placeholder='Job Description' onChange={handleJobDesc} />
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="timer">
                                    <span>{("0" + Math.floor((time / 3600000) % 60)).slice(-2)}:</span>
                                    <span>{("0" + Math.floor((time / 60000) % 60)).slice(-2)}:</span>
                                    <span>{("0" + Math.floor((time / 1000) % 60)).slice(-2)}</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div>
                                    {running ?
                                        (
                                            <>
                                                <button class="btn btn-outline-secondary" onClick={stop}>Stop</button>
                                                <button class="btn btn-outline-secondary" onClick={pause}>Pause</button>
                                            </>
                                        )
                                        :
                                        (
                                            <button class="btn btn-outline-secondary" onClick={start}>Start</button>
                                        )
                                    }
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div> */}





            20-feb=2023


            // router.post('/project', (req, res) => {
//     let projects = new projectModel(req.body);
//     projects.save((err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     })
// });


// router.get('/project', (req, res) => {
//     projectModel.find((err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     })
// })


// router.post('/task', (req, res) => {
//     let task = new taskModel(req.body);
//     task.save((err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     })
// });

// router.get('/task', (req, res) => {
//     taskModel.find((err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     })
// })

// router.post('/tracker', async (req, res) => {
//     let tracker = new trackerModel(req.body);
//     await tracker.save(async (err, data) => {
//         if (err) {
//             res.send(err.message);
//         }
//         else {
//             res.send(data);
//         };
//     });
// });

// router.get("/tracker/:_id", (req, res) => {
//     trackerModel.find({ empId: req.params._id }, (err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     })
// });

// router.get('/:_id/:range/:start/:end', async (req, res) => {
//     const { _id, range, start, end } = req.params;

//     let startDate, endDate;
//     switch (range) {
//         case 'daily':
//             startDate = moment(start).startOf('day');
//             endDate = moment(end).endOf('day');
//             break;
//         case 'weekly':
//             startDate = moment(start).startOf('week');
//             endDate = moment(end).endOf('week');
//             break;
//         case 'monthly':
//             startDate = moment(start).startOf('month');
//             endDate = moment(end).endOf('month');
//             break;
//         case 'yearly':
//             startDate = moment(start).startOf('year');
//             endDate = moment(end).endOf('year');
//             break;
//         default:
//             return res.status(400).json({ message: 'Invalid range' });
//     }

//     const data = await trackerModel.find({ empId: _id, startTime: { $gte: startDate, $lte: endDate } });
//     let total = 0;
//     data.forEach((item) => {
//         total += moment.duration(moment(item.endTime).diff(moment(item.startTime))).asHours();
//     });
//     const duration = moment.duration(total, 'hours');
//     const formattedDuration = moment.utc(duration.asMilliseconds()).format('HH:mm:ss');
//     res.json({ data, total: formattedDuration });
// });


// router.put('/tracker/:_id', async (req, res) => {
//     try {
//         let data = req.body;
//         trackerModel.findOneAndUpdate({ _id: req.params._id }, data, (err, data) => {
//             if (err) {
//                 res.send(err);
//             }
//             else {
//                 res.send(data);
//             }
//         });
//     } catch (err) {
//         res.send(err);
//     }
// });

// router.post('/login', (req, res) => {
//     let username = req.body.username;
//     let password = req.body.password;
//     userModel.findOne({ "username": username, "password": password }, (err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     })
// });

// router.post('/register', async (req, res) => {
//     let users = await new userModel(req.body);
//     if (users) {
//         users.save(async (err, data) => {
//             if (err) {
//                 res.send(err);
//             }
//             else {
//                 res.send(data);
//             }
//         })
//     }
// });

// router.get('/users', (req, res) => {
//     userModel.find((err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     });
// });

// router.put('/users/:_id', (req, res) => {
//     userModel.findByIdAndUpdate({ _id: req.params._id }, req.body, (err, data) => {
//         if (err) {
//             res.send(err);
//         }
//         else {
//             res.send(data);
//         }
//     })
// })